{"version":3,"sources":["ng://@ngxs/store/internals/memoize.ts","ng://@ngxs/store/internals/angular.ts","ng://@ngxs/store/internals/ngxs-bootstrapper.ts","ng://@ngxs/store/internals/initial-state.ts","ng://@ngxs/store/internals/internal-tokens.ts"],"names":["defaultEqualityCheck","a","b","memoize","func","equalityCheck","lastArgs","lastResult","memoized","prev","next","length","i","areArgumentsShallowlyEqual","arguments","apply","reset","isAngularInTestMode","platformRef","getPlatform","compilerOptions","injector","get","COMPILER_OPTIONS","some","item","providers","provider","provide","name","NgxsBootstrapper","this","bootstrap$","ReplaySubject","Object","defineProperty","prototype","asObservable","bootstrap","complete","Injectable","INITIAL_STATE_TOKEN","InjectionToken","InitialState","set","state","value","pop","NGXS_STATE_CONTEXT_FACTORY","NGXS_STATE_FACTORY"],"mappings":"iXAAA,SAASA,EAAqBC,EAAQC,GACpC,OAAOD,IAAMC,EA6Bf,SAAgBC,EACdC,EACAC,QAAA,IAAAA,IAAAA,EAAAL,OAEIM,EAA8B,KAC9BC,EAAkB,KAEtB,SAASC,IAOP,OAxCJ,SACEH,EACAI,EACAC,GAEA,GAAa,OAATD,GAA0B,OAATC,GAAiBD,EAAKE,SAAWD,EAAKC,OACzD,OAAO,EAKT,QADMA,EAASF,EAAKE,OACXC,EAAI,EAAGA,EAAID,EAAQC,IAC1B,IAAKP,EAAcI,EAAKG,GAAIF,EAAKE,IAC/B,OAAO,EAIX,OAAO,EAiBAC,CAA2BR,EAAeC,EAAUQ,aAEvDP,EAAa,EAAiBQ,MAAM,KAAMD,YAG5CR,EAAWQ,UACJP,EAOT,OALA,EAAgBS,MAAK,WAEnBV,EAAW,KACXC,EAAa,MAEf,EC/BF,IAAaU,EAAsBd,GAjBnC,eACQe,EAAkCC,EAAAA,cACxC,IAAKD,EAAa,OAAO,MACnBE,EAAkBF,EAAYG,SAASC,IAASC,EAAAA,iBAAkB,MACxE,QAAKH,GACgBA,EAAgBI,MAAI,SAAEC,GAEzC,OADmBA,GAAQA,EAAKC,WAAc,IAC7BF,MAAI,SAAEG,GACrB,OACGA,GAAYA,EAASC,SAAqC,yBAA1BD,EAASC,QAAQC,OAClD,WCbRC,EAAA,WAGA,SAAAA,IAKUC,KAAAC,WAAa,IAAIC,EAAAA,cAAuB,GAclD,OAZEC,OAAAC,eAAIL,EAAAM,UAAA,mBAAgB,KAApB,WACE,OAAOL,KAAKC,WAAWK,gDAOzBP,EAAAM,UAAAE,UAAA,WACEP,KAAKC,WAAWtB,MAAK,GACrBqB,KAAKC,WAAWO,gCAjBnBC,EAAAA,aAmBDV,EAtBA,GCGA,IAAaW,EAAsB,IAAIC,EAAAA,eAAoB,uBAE3DC,EAAA,WAAA,SAAAA,KAYA,OATgBA,EAAAC,IAAd,SAAkBC,GAChBd,KAAKe,MAAQD,GAGDF,EAAAI,IAAd,eACQF,EAAqBd,KAAKe,MAEhC,OADAf,KAAKe,MAAQ,GACND,GATMF,EAAAG,MAAqB,GAWtCH,EAZA,GCAA,IAAaK,EAAkD,IAAIN,EAAAA,eACjE,iCAMWO,EAA0C,IAAIP,EAAAA,eACzD","sourcesContent":["function defaultEqualityCheck(a: any, b: any) {\r\n  return a === b;\r\n}\r\n\r\nfunction areArgumentsShallowlyEqual(\r\n  equalityCheck: (a: any, b: any) => boolean,\r\n  prev: IArguments | null,\r\n  next: IArguments | null\r\n) {\r\n  if (prev === null || next === null || prev.length !== next.length) {\r\n    return false;\r\n  }\r\n\r\n  // Do this in a for loop (and not a `forEach` or an `every`) so we can determine equality as fast as possible.\r\n  const length = prev.length;\r\n  for (let i = 0; i < length; i++) {\r\n    if (!equalityCheck(prev[i], next[i])) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\n/**\r\n * Memoize a function on its last inputs only.\r\n * Originally from: https://github.com/reduxjs/reselect/blob/master/src/index.js\r\n *\r\n * @ignore\r\n */\r\nexport function memoize<T extends (...args: any[]) => any>(\r\n  func: T,\r\n  equalityCheck = defaultEqualityCheck\r\n): T {\r\n  let lastArgs: IArguments | null = null;\r\n  let lastResult: any = null;\r\n  // we reference arguments instead of spreading them for performance reasons\r\n  function memoized() {\r\n    if (!areArgumentsShallowlyEqual(equalityCheck, lastArgs, arguments)) {\r\n      // apply arguments instead of spreading for performance.\r\n      lastResult = (<Function>func).apply(null, arguments);\r\n    }\r\n\r\n    lastArgs = arguments;\r\n    return lastResult;\r\n  }\r\n  (<any>memoized).reset = function() {\r\n    // The hidden (for now) ability to reset the memoization\r\n    lastArgs = null;\r\n    lastResult = null;\r\n  };\r\n  return memoized as T;\r\n}\r\n","import { getPlatform, COMPILER_OPTIONS, CompilerOptions, PlatformRef } from '@angular/core';\r\nimport { memoize } from './memoize';\r\n\r\nfunction _isAngularInTestMode() {\r\n  const platformRef: PlatformRef | null = getPlatform();\r\n  if (!platformRef) return false;\r\n  const compilerOptions = platformRef.injector.get<any>(COMPILER_OPTIONS, null);\r\n  if (!compilerOptions) return false;\r\n  const isInTestMode = compilerOptions.some((item: CompilerOptions) => {\r\n    const providers = (item && item.providers) || [];\r\n    return providers.some((provider: any) => {\r\n      return (\r\n        (provider && provider.provide && provider.provide.name === 'MockNgModuleResolver') ||\r\n        false\r\n      );\r\n    });\r\n  });\r\n  return isInTestMode;\r\n}\r\n\r\nexport const isAngularInTestMode = memoize(_isAngularInTestMode);\r\n","import { Injectable } from '@angular/core';\r\nimport { Observable, ReplaySubject } from 'rxjs';\r\n\r\n@Injectable()\r\nexport class NgxsBootstrapper {\r\n  /**\r\n   * Use `ReplaySubject`, thus we can get cached value even if the stream is completed\r\n   */\r\n  private bootstrap$ = new ReplaySubject<boolean>(1);\r\n\r\n  get appBootstrapped$(): Observable<boolean> {\r\n    return this.bootstrap$.asObservable();\r\n  }\r\n\r\n  /**\r\n   * This event will be emitted after attaching `ComponentRef` of the root component\r\n   * to the tree of views, that's a signal that application has been fully rendered\r\n   */\r\n  bootstrap(): void {\r\n    this.bootstrap$.next(true);\r\n    this.bootstrap$.complete();\r\n  }\r\n}\r\n","import { InjectionToken } from '@angular/core';\r\nimport { PlainObject } from './symbols';\r\n\r\nexport const INITIAL_STATE_TOKEN = new InjectionToken<any>('INITIAL_STATE_TOKEN');\r\n\r\nexport class InitialState {\r\n  private static value: PlainObject = {};\r\n\r\n  public static set(state: PlainObject) {\r\n    this.value = state;\r\n  }\r\n\r\n  public static pop(): PlainObject {\r\n    const state: PlainObject = this.value;\r\n    this.value = {};\r\n    return state;\r\n  }\r\n}\r\n","import { InjectionToken } from '@angular/core';\r\n\r\n/**\r\n * @see StateContextFactory as it's referenced by this token to be accessed by plugins internally\r\n */\r\nexport const NGXS_STATE_CONTEXT_FACTORY: InjectionToken<any> = new InjectionToken(\r\n  'Internals.StateContextFactory'\r\n);\r\n\r\n/**\r\n * @see StateFactory as it's referenced by this token to be accessed by plugins internally\r\n */\r\nexport const NGXS_STATE_FACTORY: InjectionToken<any> = new InjectionToken(\r\n  'Internals.StateFactory'\r\n);\r\n"]}