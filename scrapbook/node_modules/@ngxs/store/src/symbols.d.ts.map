{"version":3,"file":"symbols.d.ts","sources":["symbols.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["import { InjectionToken, Type } from '@angular/core';\r\nimport { Observable } from 'rxjs';\r\nimport { PlainObject, StateClass } from '@ngxs/store/internals';\r\nimport { SharedSelectorOptions, Callback } from './internal/internals';\r\nimport { NgxsExecutionStrategy } from './execution/symbols';\r\nimport { StateToken } from './state-token/state-token';\r\nexport declare const ROOT_STATE_TOKEN: InjectionToken<any>;\r\nexport declare const FEATURE_STATE_TOKEN: InjectionToken<any>;\r\nexport declare const NGXS_PLUGINS: InjectionToken<{}>;\r\nexport declare const NG_TEST_MODE: InjectionToken<Callback<boolean, any>>;\r\nexport declare const NG_DEV_MODE: InjectionToken<Callback<boolean, any>>;\r\nexport declare const META_KEY = \"NGXS_META\";\r\nexport declare const META_OPTIONS_KEY = \"NGXS_OPTIONS_META\";\r\nexport declare const SELECTOR_META_KEY = \"NGXS_SELECTOR_META\";\r\nexport declare type NgxsLifeCycle = Partial<NgxsOnChanges> & Partial<NgxsOnInit> & Partial<NgxsAfterBootstrap>;\r\nexport declare type NgxsPluginFn = (state: any, mutation: any, next: NgxsNextPluginFn) => any;\r\n/**\r\n * The NGXS config settings.\r\n */\r\nexport declare class NgxsConfig {\r\n    /**\r\n     * Run in development mode. This will add additional debugging features:\r\n     * - Object.freeze on the state and actions to guarantee immutability\r\n     * (default: false)\r\n     */\r\n    developmentMode: boolean;\r\n    compatibility: {\r\n        /**\r\n         * Support a strict Content Security Policy.\r\n         * This will circumvent some optimisations that violate a strict CSP through the use of `new Function(...)`.\r\n         * (default: false)\r\n         */\r\n        strictContentSecurityPolicy: boolean;\r\n    };\r\n    /**\r\n     * Determines the execution context to perform async operations inside. An implementation can be\r\n     * provided to override the default behaviour where the async operations are run\r\n     * outside Angular's zone but all observable behaviours of NGXS are run back inside Angular's zone.\r\n     * These observable behaviours are from:\r\n     *   `@Select(...)`, `store.select(...)`, `actions.subscribe(...)` or `store.dispatch(...).subscribe(...)`\r\n     * Every `zone.run` causes Angular to run change detection on the whole tree (`app.tick()`) so of your\r\n     * application doesn't rely on zone.js running change detection then you can switch to the\r\n     * `NoopNgxsExecutionStrategy` that doesn't interact with zones.\r\n     * (default: null)\r\n     */\r\n    executionStrategy: Type<NgxsExecutionStrategy>;\r\n    /**\r\n     * Defining the default state before module initialization\r\n     * This is convenient if we need to create a define our own set of states.\r\n     * @deprecated will be removed after v4\r\n     * (default: {})\r\n     */\r\n    defaultsState: PlainObject;\r\n    /**\r\n     * Defining shared selector options\r\n     */\r\n    selectorOptions: SharedSelectorOptions;\r\n    constructor();\r\n}\r\nexport declare type StateOperator<T> = (existing: Readonly<T>) => T;\r\n/**\r\n * State context provided to the actions in the state.\r\n */\r\nexport interface StateContext<T> {\r\n    /**\r\n     * Get the current state.\r\n     */\r\n    getState(): T;\r\n    /**\r\n     * Reset the state to a new value.\r\n     */\r\n    setState(val: T | StateOperator<T>): T;\r\n    /**\r\n     * Patch the existing state with the provided value.\r\n     */\r\n    patchState(val: Partial<T>): T;\r\n    /**\r\n     * Dispatch a new action and return the dispatched observable.\r\n     */\r\n    dispatch(actions: any | any[]): Observable<void>;\r\n}\r\nexport declare type NgxsNextPluginFn = (state: any, mutation: any) => any;\r\n/**\r\n * Plugin interface\r\n */\r\nexport interface NgxsPlugin {\r\n    /**\r\n     * Handle the state/action before its submitted to the state handlers.\r\n     */\r\n    handle(state: any, action: any, next: NgxsNextPluginFn): any;\r\n}\r\n/**\r\n * Options that can be provided to the store.\r\n */\r\nexport interface StoreOptions<T> {\r\n    /**\r\n     * Name of the state. Required.\r\n     */\r\n    name: string | StateToken<T>;\r\n    /**\r\n     * Default values for the state. If not provided, uses empty object.\r\n     */\r\n    defaults?: T;\r\n    /**\r\n     * Sub states for the given state.\r\n     */\r\n    children?: StateClass[];\r\n}\r\n/**\r\n * Represents a basic change from a previous to a new value for a single state instance.\r\n * Passed as a value in a NgxsSimpleChanges object to the ngxsOnChanges hook.\r\n */\r\nexport declare class NgxsSimpleChange<T = any> {\r\n    readonly previousValue: T;\r\n    readonly currentValue: T;\r\n    readonly firstChange: boolean;\r\n    constructor(previousValue: T, currentValue: T, firstChange: boolean);\r\n}\r\n/**\r\n * On init interface\r\n */\r\nexport interface NgxsOnInit {\r\n    ngxsOnInit(ctx?: StateContext<any>): void | any;\r\n}\r\n/**\r\n * On change interface\r\n */\r\nexport interface NgxsOnChanges {\r\n    ngxsOnChanges(change: NgxsSimpleChange): void;\r\n}\r\n/**\r\n * After bootstrap interface\r\n */\r\nexport interface NgxsAfterBootstrap {\r\n    ngxsAfterBootstrap(ctx?: StateContext<any>): void;\r\n}\r\nexport declare type NgxsModuleOptions = Partial<NgxsConfig>;\r\n"]}