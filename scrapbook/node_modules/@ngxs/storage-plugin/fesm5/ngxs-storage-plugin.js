import { InjectionToken, Injectable, Inject, PLATFORM_ID, NgModule } from '@angular/core';
import { StateToken, actionMatcher, InitState, UpdateState, getValue, setValue, NGXS_PLUGINS } from '@ngxs/store';
import { __assign, __values } from 'tslib';
import { isPlatformServer } from '@angular/common';
import { tap } from 'rxjs/operators';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
var StorageOption = {
    LocalStorage: 0,
    SessionStorage: 1,
};
/**
 * @record
 */
function NgxsStoragePluginOptions() { }
if (false) {
    /**
     * Key for the state slice to store in the storage engine.
     * @type {?|undefined}
     */
    NgxsStoragePluginOptions.prototype.key;
    /**
     * Storage engine to use. Deaults to localStorage but can provide
     *
     * sessionStorage or custom implementation of the StorageEngine interface
     * @type {?|undefined}
     */
    NgxsStoragePluginOptions.prototype.storage;
    /**
     * Migration strategies.
     * @type {?|undefined}
     */
    NgxsStoragePluginOptions.prototype.migrations;
    /**
     * Serailizer for the object before its pushed into the engine.
     * @param {?} obj
     * @return {?}
     */
    NgxsStoragePluginOptions.prototype.serialize = function (obj) { };
    /**
     * Deserializer for the object before its pulled out of the engine.
     * @param {?} obj
     * @return {?}
     */
    NgxsStoragePluginOptions.prototype.deserialize = function (obj) { };
    /**
     * Method to alter object before serialization.
     * @param {?} obj
     * @param {?} key
     * @return {?}
     */
    NgxsStoragePluginOptions.prototype.beforeSerialize = function (obj, key) { };
    /**
     * Method to alter object after deserialization.
     * @param {?} obj
     * @param {?} key
     * @return {?}
     */
    NgxsStoragePluginOptions.prototype.afterDeserialize = function (obj, key) { };
}
/** @type {?} */
var NGXS_STORAGE_PLUGIN_OPTIONS = new InjectionToken('NGXS_STORAGE_PLUGIN_OPTION');
/** @type {?} */
var STORAGE_ENGINE = new InjectionToken('STORAGE_ENGINE');
/**
 * @record
 */
function StorageEngine() { }
if (false) {
    /** @type {?} */
    StorageEngine.prototype.length;
    /**
     * @param {?} key
     * @return {?}
     */
    StorageEngine.prototype.getItem = function (key) { };
    /**
     * @param {?} key
     * @param {?} val
     * @return {?}
     */
    StorageEngine.prototype.setItem = function (key, val) { };
    /**
     * @param {?} key
     * @return {?}
     */
    StorageEngine.prototype.removeItem = function (key) { };
    /**
     * @return {?}
     */
    StorageEngine.prototype.clear = function () { };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * If the `key` option is not provided then the below constant
 * will be used as a default key
 * @type {?}
 */
var DEFAULT_STATE_KEY = '@@STATE';
/**
 * This key is used to retrieve static metadatas on state classes.
 * This constant is taken from the core codebase
 * @type {?}
 */
var META_OPTIONS_KEY = 'NGXS_OPTIONS_META';
/**
 * @param {?} key
 * @return {?}
 */
function transformKeyOption(key) {
    if (!Array.isArray(key)) {
        key = [key];
    }
    return key.map((/**
     * @param {?} token
     * @return {?}
     */
    function (token) {
        // If it has the `NGXS_OPTIONS_META` key then it means the developer
        // has provided state class like `key: [AuthState]`.
        if (token.hasOwnProperty(META_OPTIONS_KEY)) {
            // The `name` property will be an actual state name or a `StateToken`.
            token = ((/** @type {?} */ (token)))[META_OPTIONS_KEY].name;
        }
        return token instanceof StateToken ? token.getName() : ((/** @type {?} */ (token)));
    }));
}
/**
 * @param {?} options
 * @return {?}
 */
function storageOptionsFactory(options) {
    if (options !== undefined && options.key) {
        options.key = transformKeyOption(options.key);
    }
    return __assign({ key: [DEFAULT_STATE_KEY], storage: 0 /* LocalStorage */, serialize: JSON.stringify, deserialize: JSON.parse, beforeSerialize: (/**
         * @param {?} obj
         * @return {?}
         */
        function (obj) { return obj; }), afterDeserialize: (/**
         * @param {?} obj
         * @return {?}
         */
        function (obj) { return obj; }) }, options);
}
/**
 * @param {?} options
 * @param {?} platformId
 * @return {?}
 */
function engineFactory(options, platformId) {
    if (isPlatformServer(platformId)) {
        return null;
    }
    if (options.storage === 0 /* LocalStorage */) {
        return localStorage;
    }
    else if (options.storage === 1 /* SessionStorage */) {
        return sessionStorage;
    }
    return null;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NgxsStoragePlugin = /** @class */ (function () {
    function NgxsStoragePlugin(_options, _engine, _platformId) {
        this._options = _options;
        this._engine = _engine;
        this._platformId = _platformId;
    }
    /**
     * @param {?} state
     * @param {?} event
     * @param {?} next
     * @return {?}
     */
    NgxsStoragePlugin.prototype.handle = /**
     * @param {?} state
     * @param {?} event
     * @param {?} next
     * @return {?}
     */
    function (state, event, next) {
        var _this = this;
        var e_1, _a;
        if (isPlatformServer(this._platformId) && this._engine === null) {
            return next(state, event);
        }
        // We cast to `string[]` here as we're sure that this option has been
        // transformed by the `storageOptionsFactory` function that provided token
        /** @type {?} */
        var keys = (/** @type {?} */ (this._options.key));
        /** @type {?} */
        var matches = actionMatcher(event);
        /** @type {?} */
        var isInitAction = matches(InitState) || matches(UpdateState);
        /** @type {?} */
        var hasMigration = false;
        if (isInitAction) {
            var _loop_1 = function (key) {
                /** @type {?} */
                var isMaster = key === DEFAULT_STATE_KEY;
                /** @type {?} */
                var val = this_1._engine.getItem((/** @type {?} */ (key)));
                if (val !== 'undefined' && typeof val !== 'undefined' && val !== null) {
                    try {
                        /** @type {?} */
                        var newVal = (/** @type {?} */ (this_1._options.deserialize))(val);
                        val = (/** @type {?} */ (this_1._options.afterDeserialize))(newVal, key);
                    }
                    catch (e) {
                        console.error('Error ocurred while deserializing the store value, falling back to empty object.');
                        val = {};
                    }
                    if (this_1._options.migrations) {
                        this_1._options.migrations.forEach((/**
                         * @param {?} strategy
                         * @return {?}
                         */
                        function (strategy) {
                            /** @type {?} */
                            var versionMatch = strategy.version === getValue(val, strategy.versionKey || 'version');
                            /** @type {?} */
                            var keyMatch = (!strategy.key && isMaster) || strategy.key === key;
                            if (versionMatch && keyMatch) {
                                val = strategy.migrate(val);
                                hasMigration = true;
                            }
                        }));
                    }
                    if (!isMaster) {
                        state = setValue(state, (/** @type {?} */ (key)), val);
                    }
                    else {
                        state = __assign({}, state, val);
                    }
                }
            };
            var this_1 = this;
            try {
                for (var keys_1 = __values(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {
                    var key = keys_1_1.value;
                    _loop_1(key);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (keys_1_1 && !keys_1_1.done && (_a = keys_1.return)) _a.call(keys_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        return next(state, event).pipe(tap((/**
         * @param {?} nextState
         * @return {?}
         */
        function (nextState) {
            var e_2, _a;
            if (!isInitAction || (isInitAction && hasMigration)) {
                try {
                    for (var keys_2 = __values(keys), keys_2_1 = keys_2.next(); !keys_2_1.done; keys_2_1 = keys_2.next()) {
                        var key = keys_2_1.value;
                        /** @type {?} */
                        var val = nextState;
                        if (key !== DEFAULT_STATE_KEY) {
                            val = getValue(nextState, (/** @type {?} */ (key)));
                        }
                        try {
                            /** @type {?} */
                            var newVal = (/** @type {?} */ (_this._options.beforeSerialize))(val, key);
                            _this._engine.setItem((/** @type {?} */ (key)), (/** @type {?} */ (_this._options.serialize))(newVal));
                        }
                        catch (e) {
                            console.error('Error ocurred while serializing the store value, value not updated.');
                        }
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (keys_2_1 && !keys_2_1.done && (_a = keys_2.return)) _a.call(keys_2);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            }
        })));
    };
    NgxsStoragePlugin.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    NgxsStoragePlugin.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: [NGXS_STORAGE_PLUGIN_OPTIONS,] }] },
        { type: undefined, decorators: [{ type: Inject, args: [STORAGE_ENGINE,] }] },
        { type: String, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }
    ]; };
    return NgxsStoragePlugin;
}());
if (false) {
    /**
     * @type {?}
     * @private
     */
    NgxsStoragePlugin.prototype._options;
    /**
     * @type {?}
     * @private
     */
    NgxsStoragePlugin.prototype._engine;
    /**
     * @type {?}
     * @private
     */
    NgxsStoragePlugin.prototype._platformId;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var USER_OPTIONS = new InjectionToken('USER_OPTIONS');
var NgxsStoragePluginModule = /** @class */ (function () {
    function NgxsStoragePluginModule() {
    }
    /**
     * @param {?=} options
     * @return {?}
     */
    NgxsStoragePluginModule.forRoot = /**
     * @param {?=} options
     * @return {?}
     */
    function (options) {
        return {
            ngModule: NgxsStoragePluginModule,
            providers: [
                {
                    provide: NGXS_PLUGINS,
                    useClass: NgxsStoragePlugin,
                    multi: true
                },
                {
                    provide: USER_OPTIONS,
                    useValue: options
                },
                {
                    provide: NGXS_STORAGE_PLUGIN_OPTIONS,
                    useFactory: storageOptionsFactory,
                    deps: [USER_OPTIONS]
                },
                {
                    provide: STORAGE_ENGINE,
                    useFactory: engineFactory,
                    deps: [NGXS_STORAGE_PLUGIN_OPTIONS, PLATFORM_ID]
                }
            ]
        };
    };
    NgxsStoragePluginModule.decorators = [
        { type: NgModule }
    ];
    return NgxsStoragePluginModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { NGXS_STORAGE_PLUGIN_OPTIONS, NgxsStoragePlugin, NgxsStoragePluginModule, STORAGE_ENGINE, USER_OPTIONS as ɵa, storageOptionsFactory as ɵb, engineFactory as ɵc };
//# sourceMappingURL=ngxs-storage-plugin.js.map
