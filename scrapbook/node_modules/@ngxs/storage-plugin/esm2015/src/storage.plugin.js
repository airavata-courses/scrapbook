/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { PLATFORM_ID, Inject, Injectable } from '@angular/core';
import { isPlatformServer } from '@angular/common';
import { setValue, getValue, InitState, UpdateState, actionMatcher } from '@ngxs/store';
import { tap } from 'rxjs/operators';
import { STORAGE_ENGINE, NGXS_STORAGE_PLUGIN_OPTIONS } from './symbols';
import { DEFAULT_STATE_KEY } from './internals';
export class NgxsStoragePlugin {
    /**
     * @param {?} _options
     * @param {?} _engine
     * @param {?} _platformId
     */
    constructor(_options, _engine, _platformId) {
        this._options = _options;
        this._engine = _engine;
        this._platformId = _platformId;
    }
    /**
     * @param {?} state
     * @param {?} event
     * @param {?} next
     * @return {?}
     */
    handle(state, event, next) {
        if (isPlatformServer(this._platformId) && this._engine === null) {
            return next(state, event);
        }
        // We cast to `string[]` here as we're sure that this option has been
        // transformed by the `storageOptionsFactory` function that provided token
        /** @type {?} */
        const keys = (/** @type {?} */ (this._options.key));
        /** @type {?} */
        const matches = actionMatcher(event);
        /** @type {?} */
        const isInitAction = matches(InitState) || matches(UpdateState);
        /** @type {?} */
        let hasMigration = false;
        if (isInitAction) {
            for (const key of keys) {
                /** @type {?} */
                const isMaster = key === DEFAULT_STATE_KEY;
                /** @type {?} */
                let val = this._engine.getItem((/** @type {?} */ (key)));
                if (val !== 'undefined' && typeof val !== 'undefined' && val !== null) {
                    try {
                        /** @type {?} */
                        const newVal = (/** @type {?} */ (this._options.deserialize))(val);
                        val = (/** @type {?} */ (this._options.afterDeserialize))(newVal, key);
                    }
                    catch (e) {
                        console.error('Error ocurred while deserializing the store value, falling back to empty object.');
                        val = {};
                    }
                    if (this._options.migrations) {
                        this._options.migrations.forEach((/**
                         * @param {?} strategy
                         * @return {?}
                         */
                        strategy => {
                            /** @type {?} */
                            const versionMatch = strategy.version === getValue(val, strategy.versionKey || 'version');
                            /** @type {?} */
                            const keyMatch = (!strategy.key && isMaster) || strategy.key === key;
                            if (versionMatch && keyMatch) {
                                val = strategy.migrate(val);
                                hasMigration = true;
                            }
                        }));
                    }
                    if (!isMaster) {
                        state = setValue(state, (/** @type {?} */ (key)), val);
                    }
                    else {
                        state = Object.assign({}, state, val);
                    }
                }
            }
        }
        return next(state, event).pipe(tap((/**
         * @param {?} nextState
         * @return {?}
         */
        nextState => {
            if (!isInitAction || (isInitAction && hasMigration)) {
                for (const key of keys) {
                    /** @type {?} */
                    let val = nextState;
                    if (key !== DEFAULT_STATE_KEY) {
                        val = getValue(nextState, (/** @type {?} */ (key)));
                    }
                    try {
                        /** @type {?} */
                        const newVal = (/** @type {?} */ (this._options.beforeSerialize))(val, key);
                        this._engine.setItem((/** @type {?} */ (key)), (/** @type {?} */ (this._options.serialize))(newVal));
                    }
                    catch (e) {
                        console.error('Error ocurred while serializing the store value, value not updated.');
                    }
                }
            }
        })));
    }
}
NgxsStoragePlugin.decorators = [
    { type: Injectable }
];
/** @nocollapse */
NgxsStoragePlugin.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [NGXS_STORAGE_PLUGIN_OPTIONS,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [STORAGE_ENGINE,] }] },
    { type: String, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    NgxsStoragePlugin.prototype._options;
    /**
     * @type {?}
     * @private
     */
    NgxsStoragePlugin.prototype._engine;
    /**
     * @type {?}
     * @private
     */
    NgxsStoragePlugin.prototype._platformId;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RvcmFnZS5wbHVnaW4uanMiLCJzb3VyY2VSb290Ijoibmc6Ly9Abmd4cy9zdG9yYWdlLXBsdWdpbi8iLCJzb3VyY2VzIjpbInNyYy9zdG9yYWdlLnBsdWdpbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ2hFLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQ25ELE9BQU8sRUFFTCxRQUFRLEVBQ1IsUUFBUSxFQUNSLFNBQVMsRUFDVCxXQUFXLEVBQ1gsYUFBYSxFQUVkLE1BQU0sYUFBYSxDQUFDO0FBQ3JCLE9BQU8sRUFBRSxHQUFHLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUVyQyxPQUFPLEVBR0wsY0FBYyxFQUNkLDJCQUEyQixFQUM1QixNQUFNLFdBQVcsQ0FBQztBQUNuQixPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxhQUFhLENBQUM7QUFHaEQsTUFBTSxPQUFPLGlCQUFpQjs7Ozs7O0lBQzVCLFlBQytDLFFBQWtDLEVBQy9DLE9BQXNCLEVBQ3pCLFdBQW1CO1FBRkgsYUFBUSxHQUFSLFFBQVEsQ0FBMEI7UUFDL0MsWUFBTyxHQUFQLE9BQU8sQ0FBZTtRQUN6QixnQkFBVyxHQUFYLFdBQVcsQ0FBUTtJQUMvQyxDQUFDOzs7Ozs7O0lBRUosTUFBTSxDQUFDLEtBQVUsRUFBRSxLQUFVLEVBQUUsSUFBc0I7UUFDbkQsSUFBSSxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksSUFBSSxDQUFDLE9BQU8sS0FBSyxJQUFJLEVBQUU7WUFDL0QsT0FBTyxJQUFJLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDO1NBQzNCOzs7O2NBSUssSUFBSSxHQUFHLG1CQUFBLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFZOztjQUNwQyxPQUFPLEdBQUcsYUFBYSxDQUFDLEtBQUssQ0FBQzs7Y0FDOUIsWUFBWSxHQUFHLE9BQU8sQ0FBQyxTQUFTLENBQUMsSUFBSSxPQUFPLENBQUMsV0FBVyxDQUFDOztZQUMzRCxZQUFZLEdBQUcsS0FBSztRQUV4QixJQUFJLFlBQVksRUFBRTtZQUNoQixLQUFLLE1BQU0sR0FBRyxJQUFJLElBQUksRUFBRTs7c0JBQ2hCLFFBQVEsR0FBRyxHQUFHLEtBQUssaUJBQWlCOztvQkFDdEMsR0FBRyxHQUFRLElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLG1CQUFBLEdBQUcsRUFBQyxDQUFDO2dCQUV6QyxJQUFJLEdBQUcsS0FBSyxXQUFXLElBQUksT0FBTyxHQUFHLEtBQUssV0FBVyxJQUFJLEdBQUcsS0FBSyxJQUFJLEVBQUU7b0JBQ3JFLElBQUk7OzhCQUNJLE1BQU0sR0FBRyxtQkFBQSxJQUFJLENBQUMsUUFBUSxDQUFDLFdBQVcsRUFBQyxDQUFDLEdBQUcsQ0FBQzt3QkFDOUMsR0FBRyxHQUFHLG1CQUFBLElBQUksQ0FBQyxRQUFRLENBQUMsZ0JBQWdCLEVBQUMsQ0FBQyxNQUFNLEVBQUUsR0FBRyxDQUFDLENBQUM7cUJBQ3BEO29CQUFDLE9BQU8sQ0FBQyxFQUFFO3dCQUNWLE9BQU8sQ0FBQyxLQUFLLENBQ1gsa0ZBQWtGLENBQ25GLENBQUM7d0JBQ0YsR0FBRyxHQUFHLEVBQUUsQ0FBQztxQkFDVjtvQkFFRCxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsVUFBVSxFQUFFO3dCQUM1QixJQUFJLENBQUMsUUFBUSxDQUFDLFVBQVUsQ0FBQyxPQUFPOzs7O3dCQUFDLFFBQVEsQ0FBQyxFQUFFOztrQ0FDcEMsWUFBWSxHQUNoQixRQUFRLENBQUMsT0FBTyxLQUFLLFFBQVEsQ0FBQyxHQUFHLEVBQUUsUUFBUSxDQUFDLFVBQVUsSUFBSSxTQUFTLENBQUM7O2tDQUNoRSxRQUFRLEdBQUcsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxHQUFHLElBQUksUUFBUSxDQUFDLElBQUksUUFBUSxDQUFDLEdBQUcsS0FBSyxHQUFHOzRCQUNwRSxJQUFJLFlBQVksSUFBSSxRQUFRLEVBQUU7Z0NBQzVCLEdBQUcsR0FBRyxRQUFRLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDO2dDQUM1QixZQUFZLEdBQUcsSUFBSSxDQUFDOzZCQUNyQjt3QkFDSCxDQUFDLEVBQUMsQ0FBQztxQkFDSjtvQkFFRCxJQUFJLENBQUMsUUFBUSxFQUFFO3dCQUNiLEtBQUssR0FBRyxRQUFRLENBQUMsS0FBSyxFQUFFLG1CQUFBLEdBQUcsRUFBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDO3FCQUNwQzt5QkFBTTt3QkFDTCxLQUFLLHFCQUFRLEtBQUssRUFBSyxHQUFHLENBQUUsQ0FBQztxQkFDOUI7aUJBQ0Y7YUFDRjtTQUNGO1FBRUQsT0FBTyxJQUFJLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDLElBQUksQ0FDNUIsR0FBRzs7OztRQUFDLFNBQVMsQ0FBQyxFQUFFO1lBQ2QsSUFBSSxDQUFDLFlBQVksSUFBSSxDQUFDLFlBQVksSUFBSSxZQUFZLENBQUMsRUFBRTtnQkFDbkQsS0FBSyxNQUFNLEdBQUcsSUFBSSxJQUFJLEVBQUU7O3dCQUNsQixHQUFHLEdBQUcsU0FBUztvQkFFbkIsSUFBSSxHQUFHLEtBQUssaUJBQWlCLEVBQUU7d0JBQzdCLEdBQUcsR0FBRyxRQUFRLENBQUMsU0FBUyxFQUFFLG1CQUFBLEdBQUcsRUFBQyxDQUFDLENBQUM7cUJBQ2pDO29CQUVELElBQUk7OzhCQUNJLE1BQU0sR0FBRyxtQkFBQSxJQUFJLENBQUMsUUFBUSxDQUFDLGVBQWUsRUFBQyxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUM7d0JBQ3ZELElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLG1CQUFBLEdBQUcsRUFBQyxFQUFFLG1CQUFBLElBQUksQ0FBQyxRQUFRLENBQUMsU0FBUyxFQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztxQkFDOUQ7b0JBQUMsT0FBTyxDQUFDLEVBQUU7d0JBQ1YsT0FBTyxDQUFDLEtBQUssQ0FDWCxxRUFBcUUsQ0FDdEUsQ0FBQztxQkFDSDtpQkFDRjthQUNGO1FBQ0gsQ0FBQyxFQUFDLENBQ0gsQ0FBQztJQUNKLENBQUM7OztZQS9FRixVQUFVOzs7OzRDQUdOLE1BQU0sU0FBQywyQkFBMkI7NENBQ2xDLE1BQU0sU0FBQyxjQUFjO3lDQUNyQixNQUFNLFNBQUMsV0FBVzs7Ozs7OztJQUZuQixxQ0FBK0U7Ozs7O0lBQy9FLG9DQUFzRDs7Ozs7SUFDdEQsd0NBQWdEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUExBVEZPUk1fSUQsIEluamVjdCwgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBpc1BsYXRmb3JtU2VydmVyIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcclxuaW1wb3J0IHtcclxuICBOZ3hzUGx1Z2luLFxyXG4gIHNldFZhbHVlLFxyXG4gIGdldFZhbHVlLFxyXG4gIEluaXRTdGF0ZSxcclxuICBVcGRhdGVTdGF0ZSxcclxuICBhY3Rpb25NYXRjaGVyLFxyXG4gIE5neHNOZXh0UGx1Z2luRm5cclxufSBmcm9tICdAbmd4cy9zdG9yZSc7XHJcbmltcG9ydCB7IHRhcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcclxuXHJcbmltcG9ydCB7XHJcbiAgU3RvcmFnZUVuZ2luZSxcclxuICBOZ3hzU3RvcmFnZVBsdWdpbk9wdGlvbnMsXHJcbiAgU1RPUkFHRV9FTkdJTkUsXHJcbiAgTkdYU19TVE9SQUdFX1BMVUdJTl9PUFRJT05TXHJcbn0gZnJvbSAnLi9zeW1ib2xzJztcclxuaW1wb3J0IHsgREVGQVVMVF9TVEFURV9LRVkgfSBmcm9tICcuL2ludGVybmFscyc7XHJcblxyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBOZ3hzU3RvcmFnZVBsdWdpbiBpbXBsZW1lbnRzIE5neHNQbHVnaW4ge1xyXG4gIGNvbnN0cnVjdG9yKFxyXG4gICAgQEluamVjdChOR1hTX1NUT1JBR0VfUExVR0lOX09QVElPTlMpIHByaXZhdGUgX29wdGlvbnM6IE5neHNTdG9yYWdlUGx1Z2luT3B0aW9ucyxcclxuICAgIEBJbmplY3QoU1RPUkFHRV9FTkdJTkUpIHByaXZhdGUgX2VuZ2luZTogU3RvcmFnZUVuZ2luZSxcclxuICAgIEBJbmplY3QoUExBVEZPUk1fSUQpIHByaXZhdGUgX3BsYXRmb3JtSWQ6IHN0cmluZ1xyXG4gICkge31cclxuXHJcbiAgaGFuZGxlKHN0YXRlOiBhbnksIGV2ZW50OiBhbnksIG5leHQ6IE5neHNOZXh0UGx1Z2luRm4pIHtcclxuICAgIGlmIChpc1BsYXRmb3JtU2VydmVyKHRoaXMuX3BsYXRmb3JtSWQpICYmIHRoaXMuX2VuZ2luZSA9PT0gbnVsbCkge1xyXG4gICAgICByZXR1cm4gbmV4dChzdGF0ZSwgZXZlbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFdlIGNhc3QgdG8gYHN0cmluZ1tdYCBoZXJlIGFzIHdlJ3JlIHN1cmUgdGhhdCB0aGlzIG9wdGlvbiBoYXMgYmVlblxyXG4gICAgLy8gdHJhbnNmb3JtZWQgYnkgdGhlIGBzdG9yYWdlT3B0aW9uc0ZhY3RvcnlgIGZ1bmN0aW9uIHRoYXQgcHJvdmlkZWQgdG9rZW5cclxuICAgIGNvbnN0IGtleXMgPSB0aGlzLl9vcHRpb25zLmtleSBhcyBzdHJpbmdbXTtcclxuICAgIGNvbnN0IG1hdGNoZXMgPSBhY3Rpb25NYXRjaGVyKGV2ZW50KTtcclxuICAgIGNvbnN0IGlzSW5pdEFjdGlvbiA9IG1hdGNoZXMoSW5pdFN0YXRlKSB8fCBtYXRjaGVzKFVwZGF0ZVN0YXRlKTtcclxuICAgIGxldCBoYXNNaWdyYXRpb24gPSBmYWxzZTtcclxuXHJcbiAgICBpZiAoaXNJbml0QWN0aW9uKSB7XHJcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcclxuICAgICAgICBjb25zdCBpc01hc3RlciA9IGtleSA9PT0gREVGQVVMVF9TVEFURV9LRVk7XHJcbiAgICAgICAgbGV0IHZhbDogYW55ID0gdGhpcy5fZW5naW5lLmdldEl0ZW0oa2V5ISk7XHJcblxyXG4gICAgICAgIGlmICh2YWwgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB2YWwgIT09ICd1bmRlZmluZWQnICYmIHZhbCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgbmV3VmFsID0gdGhpcy5fb3B0aW9ucy5kZXNlcmlhbGl6ZSEodmFsKTtcclxuICAgICAgICAgICAgdmFsID0gdGhpcy5fb3B0aW9ucy5hZnRlckRlc2VyaWFsaXplIShuZXdWYWwsIGtleSk7XHJcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXHJcbiAgICAgICAgICAgICAgJ0Vycm9yIG9jdXJyZWQgd2hpbGUgZGVzZXJpYWxpemluZyB0aGUgc3RvcmUgdmFsdWUsIGZhbGxpbmcgYmFjayB0byBlbXB0eSBvYmplY3QuJ1xyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB2YWwgPSB7fTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy5taWdyYXRpb25zKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX29wdGlvbnMubWlncmF0aW9ucy5mb3JFYWNoKHN0cmF0ZWd5ID0+IHtcclxuICAgICAgICAgICAgICBjb25zdCB2ZXJzaW9uTWF0Y2ggPVxyXG4gICAgICAgICAgICAgICAgc3RyYXRlZ3kudmVyc2lvbiA9PT0gZ2V0VmFsdWUodmFsLCBzdHJhdGVneS52ZXJzaW9uS2V5IHx8ICd2ZXJzaW9uJyk7XHJcbiAgICAgICAgICAgICAgY29uc3Qga2V5TWF0Y2ggPSAoIXN0cmF0ZWd5LmtleSAmJiBpc01hc3RlcikgfHwgc3RyYXRlZ3kua2V5ID09PSBrZXk7XHJcbiAgICAgICAgICAgICAgaWYgKHZlcnNpb25NYXRjaCAmJiBrZXlNYXRjaCkge1xyXG4gICAgICAgICAgICAgICAgdmFsID0gc3RyYXRlZ3kubWlncmF0ZSh2YWwpO1xyXG4gICAgICAgICAgICAgICAgaGFzTWlncmF0aW9uID0gdHJ1ZTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGlmICghaXNNYXN0ZXIpIHtcclxuICAgICAgICAgICAgc3RhdGUgPSBzZXRWYWx1ZShzdGF0ZSwga2V5ISwgdmFsKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHN0YXRlID0geyAuLi5zdGF0ZSwgLi4udmFsIH07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG5leHQoc3RhdGUsIGV2ZW50KS5waXBlKFxyXG4gICAgICB0YXAobmV4dFN0YXRlID0+IHtcclxuICAgICAgICBpZiAoIWlzSW5pdEFjdGlvbiB8fCAoaXNJbml0QWN0aW9uICYmIGhhc01pZ3JhdGlvbikpIHtcclxuICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcclxuICAgICAgICAgICAgbGV0IHZhbCA9IG5leHRTdGF0ZTtcclxuXHJcbiAgICAgICAgICAgIGlmIChrZXkgIT09IERFRkFVTFRfU1RBVEVfS0VZKSB7XHJcbiAgICAgICAgICAgICAgdmFsID0gZ2V0VmFsdWUobmV4dFN0YXRlLCBrZXkhKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICBjb25zdCBuZXdWYWwgPSB0aGlzLl9vcHRpb25zLmJlZm9yZVNlcmlhbGl6ZSEodmFsLCBrZXkpO1xyXG4gICAgICAgICAgICAgIHRoaXMuX2VuZ2luZS5zZXRJdGVtKGtleSEsIHRoaXMuX29wdGlvbnMuc2VyaWFsaXplIShuZXdWYWwpKTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXHJcbiAgICAgICAgICAgICAgICAnRXJyb3Igb2N1cnJlZCB3aGlsZSBzZXJpYWxpemluZyB0aGUgc3RvcmUgdmFsdWUsIHZhbHVlIG5vdCB1cGRhdGVkLidcclxuICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9KVxyXG4gICAgKTtcclxuICB9XHJcbn1cclxuIl19