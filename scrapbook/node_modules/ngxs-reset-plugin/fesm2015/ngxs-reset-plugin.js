import { Injectable, isDevMode, APP_INITIALIZER, NgModule } from '@angular/core';
import { ofActionSuccessful, InitState, UpdateState, Actions, Store, getStoreMetadata, getValue, setValue, getActionTypeFromInstance, NGXS_PLUGINS } from '@ngxs/store';
import { take } from 'rxjs/operators';

/**
 * @fileoverview added by tsickle
 * Generated from: lib/internals.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function MetaDataModel() { }
if (false) {
    /** @type {?} */
    MetaDataModel.prototype.name;
    /** @type {?} */
    MetaDataModel.prototype.defaults;
    /** @type {?} */
    MetaDataModel.prototype.path;
    /** @type {?|undefined} */
    MetaDataModel.prototype.children;
}
/**
 * a simplified implementation of NGXS StateClass interface
 * @record
 * @template T
 */
function StateClass() { }
if (false) {
    /** @type {?|undefined} */
    StateClass.prototype.NGXS_META;
    /* Skipping unhandled member: new (...args: any[]): T;*/
}
/**
 * @return {?}
 */
function noop() {
    return (/**
     * @return {?}
     */
    () => { });
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/reset.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ResetService {
}
ResetService.decorators = [
    { type: Injectable }
];
if (false) {
    /** @type {?} */
    ResetService.prototype.initialState;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/reset.handler.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ResetHandler {
    /**
     * @param {?} actions$
     * @param {?} store
     * @param {?} resetService
     */
    constructor(actions$, store, resetService) {
        this.actions$ = actions$;
        this.store = store;
        this.resetService = resetService;
        this.actions$
            .pipe(ofActionSuccessful(InitState), take(1))
            .subscribe((/**
         * @return {?}
         */
        () => (this.resetService.initialState = this.store.snapshot())));
        this.actions$.pipe(ofActionSuccessful(UpdateState)).subscribe((/**
         * @param {?} __0
         * @return {?}
         */
        ({ addedStates }) => (this.resetService.initialState = Object.assign(Object.assign({}, this.resetService.initialState), addedStates))));
    }
}
ResetHandler.decorators = [
    { type: Injectable }
];
/** @nocollapse */
ResetHandler.ctorParameters = () => [
    { type: Actions },
    { type: Store },
    { type: ResetService }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    ResetHandler.prototype.actions$;
    /**
     * @type {?}
     * @private
     */
    ResetHandler.prototype.store;
    /**
     * @type {?}
     * @private
     */
    ResetHandler.prototype.resetService;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/symbols.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Action to clear all state except given state(s)
 */
class StateClear {
    /**
     * @param {...?} statesToKeep
     */
    constructor(...statesToKeep) {
        /** @type {?} */
        const reducer = createMetaDataListReducer(isDevMode());
        this.statesToKeep = statesToKeep.reduce(reducer, []);
    }
}
StateClear.type = '@@CLEAR_STATE';
if (false) {
    /** @type {?} */
    StateClear.type;
    /** @type {?} */
    StateClear.prototype.statesToKeep;
}
/**
 * Action to reset given state(s) to defaults
 */
class StateReset {
    /**
     * @param {...?} statesToReset
     */
    constructor(...statesToReset) {
        /** @type {?} */
        const reducer = createMetaDataListReducer(isDevMode());
        this.statesToReset = statesToReset.reduce(reducer, []);
    }
}
StateReset.type = '@@RESET_STATE';
if (false) {
    /** @type {?} */
    StateReset.type;
    /** @type {?} */
    StateReset.prototype.statesToReset;
}
/**
 * Action to reset all states expect given state(s) to defaults
 */
class StateResetAll {
    /**
     * @param {...?} statesToKeep
     */
    constructor(...statesToKeep) {
        /** @type {?} */
        const reducer = createMetaDataListReducer(isDevMode());
        this.statesToKeep = statesToKeep.reduce(reducer, []);
    }
}
StateResetAll.type = '@@RESET_STATE_ALL';
if (false) {
    /** @type {?} */
    StateResetAll.type;
    /** @type {?} */
    StateResetAll.prototype.statesToKeep;
}
/**
 * Action to overwrite state(s) with given value(s)
 */
class StateOverwrite {
    /**
     * @param {...?} overwriteConfigs
     */
    constructor(...overwriteConfigs) {
        /** @type {?} */
        const reducer = createMetaTupleReducer(isDevMode());
        const [states, values] = overwriteConfigs.reduce(reducer, [
            [],
            [],
        ]);
        this.statesToOverwrite = states;
        this.values = values;
    }
}
StateOverwrite.type = '@@OVERWRITE_STATE';
if (false) {
    /** @type {?} */
    StateOverwrite.type;
    /** @type {?} */
    StateOverwrite.prototype.statesToOverwrite;
    /** @type {?} */
    StateOverwrite.prototype.values;
}
/**
 * @param {?} state
 * @param {?} devMode
 * @return {?}
 */
function getMetaData(state, devMode) {
    /** @type {?} */
    const meta = (/** @type {?} */ (new Object(getStoreMetadata((/** @type {?} */ (state))))));
    /** @type {?} */
    const isNgxsMeta = meta.name && 'defaults' in meta;
    // Reusability Hack: devMode is number on purpose
    if (!isNgxsMeta && devMode === -2) {
        console.warn(`Reset Plugin Warning: ${meta.name} is not a state class.`);
        return null;
    }
    return meta;
}
/**
 * @param {?} devMode
 * @return {?}
 */
function createMetaDataListReducer(devMode) {
    return (/**
     * @param {?} acc
     * @param {?} state
     * @return {?}
     */
    (acc, state) => {
        // tslint:disable-next-line:no-bitwise
        /** @type {?} */
        const meta = getMetaData(state, ~devMode);
        return meta ? acc.concat(meta) : acc;
    });
}
/**
 * @param {?} devMode
 * @return {?}
 */
function createMetaTupleReducer(devMode) {
    return (/**
     * @param {?} acc
     * @param {?} __1
     * @return {?}
     */
    (acc, [state, value]) => {
        // tslint:disable-next-line:no-bitwise
        /** @type {?} */
        const meta = getMetaData(state, ~devMode);
        return meta ? [acc[0].concat(meta), acc[1].concat(value)] : acc;
    });
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/reset.plugin.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxsResetPlugin {
    /**
     * @param {?} resetService
     */
    constructor(resetService) {
        this.resetService = resetService;
    }
    /**
     * @private
     * @param {?} state
     * @param {?} statesToKeep
     * @return {?}
     */
    clearStates(state, statesToKeep) {
        return statesToKeep
            .map((/**
         * @param {?} meta
         * @return {?}
         */
        meta => getPath(meta)))
            .map((/**
         * @param {?} path
         * @return {?}
         */
        path => ({
            parts: path.split('.'),
            value: getValue(state, path),
        })))
            .reduce((/**
         * @param {?} obj
         * @param {?} __1
         * @return {?}
         */
        (obj, { parts, value }) => parts.reduceRight((/**
         * @param {?} acc
         * @param {?} part
         * @return {?}
         */
        (acc, part) => part in obj
            ? {
                [part]: Object.assign(Object.assign({}, obj[part]), acc),
            }
            : { [part]: acc }), value)), (/** @type {?} */ ({})));
    }
    /**
     * @private
     * @param {?} state
     * @param {?} statesToOverwrite
     * @param {?} values
     * @return {?}
     */
    overwriteStates(state, statesToOverwrite, values) {
        statesToOverwrite.forEach((/**
         * @param {?} meta
         * @param {?} index
         * @return {?}
         */
        (meta, index) => (state = setValue(state, getPath(meta), values[index]))));
        return state;
    }
    /**
     * @private
     * @param {?} state
     * @param {?} statesToReset
     * @return {?}
     */
    resetStates(state, statesToReset) {
        statesToReset.forEach((/**
         * @param {?} meta
         * @return {?}
         */
        meta => {
            state = setValue(state, getPath(meta), typeof meta.defaults === 'undefined' ? {} : meta.defaults);
            if (meta.children) {
                state = this.resetStates(state, (/** @type {?} */ (meta.children.map(getMetaData))));
            }
        }));
        return state;
    }
    /**
     * @private
     * @param {?} state
     * @param {?} statesToKeep
     * @return {?}
     */
    resetStatesAll(state, statesToKeep) {
        /** @type {?} */
        const values = statesToKeep.map((/**
         * @param {?} meta
         * @return {?}
         */
        meta => getValue(state, getPath(meta))));
        return this.overwriteStates(this.resetService.initialState, statesToKeep, values);
    }
    /**
     * @param {?} state
     * @param {?} action
     * @param {?} next
     * @return {?}
     */
    handle(state, action, next) {
        /** @type {?} */
        const type = getActionTypeFromInstance(action);
        switch (type) {
            case StateClear.type:
                state = this.clearStates(state, ((/** @type {?} */ (action))).statesToKeep);
                break;
            case StateReset.type:
                state = this.resetStates(state, ((/** @type {?} */ (action))).statesToReset);
                break;
            case StateResetAll.type:
                state = this.resetStatesAll(state, ((/** @type {?} */ (action))).statesToKeep);
                break;
            case StateOverwrite.type:
                const { statesToOverwrite, values } = (/** @type {?} */ (action));
                state = this.overwriteStates(state, statesToOverwrite, values);
                break;
            default:
                break;
        }
        return next(state, action);
    }
}
NgxsResetPlugin.decorators = [
    { type: Injectable }
];
/** @nocollapse */
NgxsResetPlugin.ctorParameters = () => [
    { type: ResetService }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    NgxsResetPlugin.prototype.resetService;
}
/**
 * @param {?} meta
 * @return {?}
 */
function getPath(meta) {
    return meta.path;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/reset.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxsResetPluginModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: NgxsResetPluginModule,
            providers: [
                ResetService,
                ResetHandler,
                {
                    provide: APP_INITIALIZER,
                    useFactory: noop,
                    deps: [ResetHandler],
                    multi: true,
                },
                {
                    provide: NGXS_PLUGINS,
                    useClass: NgxsResetPlugin,
                    multi: true,
                },
            ],
        };
    }
}
NgxsResetPluginModule.decorators = [
    { type: NgModule }
];

/**
 * @fileoverview added by tsickle
 * Generated from: public_api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: ngxs-reset-plugin.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { NgxsResetPlugin, NgxsResetPluginModule, StateClear, StateOverwrite, StateReset, StateResetAll, getMetaData, ResetService as ɵa, ResetHandler as ɵb, noop as ɵd };
//# sourceMappingURL=ngxs-reset-plugin.js.map
